# shellcheck shell=bash

# author:       Li Junhao           edwin.jh.lee@gmail.com    edwinjhlee.github.io
# maintainer:   Li Junhao

assert.selftest(){
    @src std/test
    test.doctest "${BASH_SOURCE[0]}"
}

# assert(){
#     if [ $# -ne 0 ]; then
#         eval "$*"
#     else
#         code=$(cat)
#         eval "$code"
#     fi

#     # shellcheck disable=SC2181
#     if [ "$?" -eq 0 ]; then
#         return 0
#     else
#         echo "$MSG"
#         return 1
#     fi
# }

# assert "$org" =~ [\d]{2} [\d]{4}
# assert "$repo" = gitee


# @assert(){
#     local value=${!1}
#     shift
#     assert "$value" "$@"
# }

# design principle:
# when to use name evaluation?
# 

: <<DOCTEST
> assert "a1b2c" =~ [0-9]+ [a-z0-9]+ && echo yes
yes
> assert "a1b2c" = 123 a1b2 1b2c 2>/dev/null && echo yes
> assert "a1b2c" = 123 a1b2 a1b2c 1b2c && echo yes
yes
> assert 123 =int && echo yes
yes
> assert a123 =int 2>/dev/null && echo yes
> assert a1,a6,a3 =[,] a1 a2 a3 a4 a5 a6 2>/dev/null && echo yes
yes
> assert a1,a6,a3 =[,] a1 a2 a3 a4 a5 2>/dev/null && echo yes
> assert a1,a6,a3 =, a1 a2 a3 a4 a5 a6 2>/dev/null && echo yes
yes
> assert a1,a6,a3 =, a1 a2 a3 a4 a5 2>/dev/null && echo yes
> assert a1,a6,a3 =~[,] a[1-6] 2>/dev/null && echo yes
yes
> assert a1,a6,a3 =~[,] a[1-3] 2>/dev/null && echo yes
DOCTEST
assert(){
    # shellcheck disable=SC2016
    local CHOICE_LIST_MUST_NOT_BE_EMTPY='
        [ "${#@}" -eq 0 ] && {
            echo "ERROR: Please provide candidate list right after $op for parameter[$name]" >&2
            return 0
        }
    '

    local IFS=$'\n'

    local val="$1" op="$2"; shift 2
    case "$op" in
    =~)
        eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"
        if ! assert.within_regex "$val" "$@"; then
            echo "ERROR: '$val' NOT match any regex defined" >&2
            # param.help.show
            return 1
        fi;;
    =)
        eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"
        if ! assert.within "$val" "$@"; then
            # echo "$val" "$@" >&2
            echo "ERROR: '$val' Not one of the candidate set." >&2
            # param.help.show
            return 1
        fi ;;
    =str | =int)
        if [ -z "${val}" ]; then
            echo "ERROR: A non-null value is expected for parameter" >&2
            # param.help.show
            return 1
        fi

        if [ "$op" = "=int" ]; then
            if  [[ ! "$val" =~ ^[\ \t]*[0-9]+[\ \t]*$ ]]; then
                echo "ERROR: '$val' An integer expected." >&2
                # param.help.show
                return 1
            fi
        fi

        [ "${#@}" -ne 0 ] && {
            if ! assert.within "$val" "$@"; then
                echo "ERROR: '$val' Not inside the $op set." >&2
                # param.help.show
                return 1
            fi 
        } ;;
    =\[?\] | =?)
        eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"

        local sep=${op:1:1};
        [[ "$op" == '=['?']' ]] &&  sep=${op:2:1}
        # shellcheck disable=SC2207
        local data=( $(echo "$val" | tr "$sep" '\n') ) # should not quote '$(...)'
        [ ${#data[@]} -eq 0 ] && data=("")

        local datum
        for datum in "${data[@]}"; do
            if ! assert.within "$datum" "$@"; then
                echo "ERROR: ['$val'] After splited with \'$sep\', element '$datum' does NOT match the string set" >&2
                # param.help.show
                return 1
            fi
        done ;;
    =~\[?\] | =~? )
        eval "$CHOICE_LIST_MUST_NOT_BE_EMTPY"

        local sep=${op:2:1};    
        [[ "$op" == '=~['?']' ]] && sep=${op:3:1}
        # shellcheck disable=SC2207
        local data=( $(echo "$val" | tr "$sep" '\n') ) # should not quote '$(...)'
        [ ${#data[@]} -eq 0 ] && data=("")

        local datum
        for datum in "${data[@]}"; do
            assert.within_regex "$datum" "$@" && continue
            echo "ERROR: ['$val']. After splited with \'$sep\', element '$datum' does NOT match the regex set." >&2
            # param.help.show
            return 1
        done ;;
    *)  [ "$op" == "" ] || echo ": TODO: $op" >&2 ;;
    esac

    return 0

    # if [[ "$op" == '=~['?']' ]]; then
    #     [[ ! "$name" == \\\$* ]] && {
    #         echo "local $name 2>/dev/null"
    #         echo "$name=$(list.repr "${data[@]}")"
    #     }
    #     return 0 # continue
    # fi ;;

    # if [[ "$op" == '=['?']' ]]; then
    #     [[ ! "$name" == \\\$* ]] && {
    #         echo "local $name 2>/dev/null"
    #         echo "$name=$(list.repr "${data[@]}")"
    #     }
    #     return 0 # continue
    # fi ;;

    # [[ ! "$name" == \\\$* ]] && {
    #     echo "local $name 2>/dev/null"
    #     echo "$name=$(str.repr "$val")"
    # }
    # return 0
}

# assert(){
#     local value="$1"
#     local op="$2"
#     shift 2
#     case "$op" in
#     =) assert.within "$value" "$@";;
#     =~) assert.within_regex "$value" "$@";;
#     *) return 1;;
#     esac
# }

: <<DOCTEST
> assert.within 1abc 1abc1 1abc2 && echo yes
> assert.within 1abc 1abc1 1abc2 1abc abc3 && echo yes
yes
DOCTEST
assert.within(){
    local c value="$1"
    shift
    for c in "$@"; do
        if [ "$value" = "$c" ]; then
            return 0
        fi
    done
    return 1
}


: <<DOCTEST
> assert.within_regex 1abc 1abc1 1abc2 && echo yes
> assert.within_regex 1abc 1abc1 1abc2 1abc abc3 && echo yes
yes
> assert.within_regex 1abc 1abc1 1abc2 [0-9][a-z]+ abc3 && echo yes
yes
DOCTEST
assert.within_regex(){
    local c value="$1"
    shift
    for c in "$@"; do
        # echo "--- $value" "^($c)$" >&2
        if [[ "$value" =~ ^($c)$ ]]; then
            return 0
        fi
    done
    return 1
}

: <<DOCTEST
> assert.eq 1abc 1abc1 1abc2 2>/dev/null && echo yes
> assert.eq 1abc 1abc 1abc && echo yes
yes
DOCTEST
assert.eq(){
    local real=${1:?Real value}
    while [ $# -gt 1 ]; do
        shift
        if [ "$real" != "$1" ]; then
            echo "Failed. Expect '$real' equals to '$1'" >&2
            return 1
        fi
    done
    return 0
}


: <<DOCTEST
> assert.t "sleep 1s" 2>/dev/null && echo yes
yes
> assert.t "[ 5 -eq 3 ]" 2>/dev/null && echo yes
> assert.t "[ 3 -eq 3 ]" 2>/dev/null && echo yes
yes
DOCTEST
assert.t(){
    if eval "$*"; then
        return 0
    else
        echo "${MSG:-"Expect command execution to be true: $*"}" >&2
        return 1
    fi
}

: <<DOCTEST
> assert.f "sleep 1s" 2>/dev/null && echo yes
> assert.f "[ 5 -eq 3 ]" 2>/dev/null && echo yes
yes
> assert.f "[ 3 -eq 3 ]" 2>/dev/null && echo yes
DOCTEST
assert.f(){
    if eval "$*"; then
        echo "${MSG:-"Expect command execution to be false: $*"}" >&2
        return 1
    else
        return 0
    fi
}

# There is two ways to use assert.grep
: <<DOCTEST
> assert.grep hi <<<"hello hi" 1>/dev/null && echo yes
yes
> assert.grep "test.doctest" 2>/dev/null <"${BASH_SOURCE[0]}" && echo yes
yes
DOCTEST
assert.grep(){
    if grep "${1:?Please provide grep pattern}" 1>/dev/null; then
        return 0
    else
        echo "${MSG:-Grep Pattern Failed matching: $1}" >&2
        return 1
    fi
}

: <<DOCTEST
> assert.float 1.2 1.0 1.1 34.1 && echo yes
yes
> assert.float 1.2 1.0 1.- 34 2>/dev/null && echo yes
DOCTEST
assert.float(){
    while [ $# -gt 0 ]; do
        [[ "$1" =~ ^[\ \t]?[0-9]+(.[0-9]+)?[\ \t]?$ ]] || {
            echo "${MSG:-"Expect var to be of float type: $*"}" >&2
            return 1
        }
        shift
    done
    return 0
}

: <<DOCTEST
> assert.int 1 2 3 " 5 " && echo yes
yes
> assert.int 1 2 1.2 3 2>/dev/null && echo yes
DOCTEST
assert.int(){
    while [ $# -gt 0 ]; do
        [[ "$1" =~ ^[\ \t]?[0-9]+[\ \t]?$ ]] || {
            echo "${MSG:-"Expect var to be of int type: $*"}" >&2
            return 1
        }
        shift
    done
    return 0
}

: <<DOCTEST
> a=3; b=(1 2 3); c=8; d=(3 8)
> assert.var.is_array a b c 2>/dev/null && echo yes
> assert.var.is_array b d && echo yes
yes
DOCTEST
assert.var.is_array(){
    while [ $# -gt 0 ]; do
        if ! declare -p "${1:?Please provide variable name}" 2> /dev/null | grep -q '^declare \-a'; then
            echo "${MSG:-"Expect var to be of array type: $*"}" >&2
            return 1
        fi
        shift
    done
    return 0
}

testFun(){
    # Do it in usual way
    local TMP_1 TMP_2
    TMP_1=$(file.tmp)
    TMP_2=$(file.tmp)
    
    docker run -it ubuntu bash > "$TMP_1"
    MSG="testFun failed" \
        assert.grep "work" -- "work" <"$TMP_1"
    assert.grep "$(line "$TMP_1" 2)" "$TMP_2"
    MSG="testFun failed for reason like" \
        assert.grep "$(line "$TMP_1" 3)" "$TMP_2"

    # assert.grep "work" -- "testFun failed" <$TMP_1
    # assert.grep $(line $TMP_1 2) $TMP_2
    # assert.grep "$(line $TMP_1 3)" $TMP_2 -- "testFun failed for reason like" 

    # assert.eq 2 $(line $TMP_1 3)
    # assert.eq 2 $(file.line $TMP_1 3)
    # assert.eq 2 $(sed -n 3p $TMP_1)
}

# Example:
# TIMEOUT=3 MSGURE="Fail if wrong" @ts "work1" testFun1
# TIMEOUT=3 MSGURE="Fail if wrong" @testsuite "work1" testFun1
# TIMEOUT=5 @ts "work2" testFun2


: <<DOCTEST
> a=3; b=(1 2 3); c=
> assert.var.not_empty a b c && echo yes
> assert.var.not_empty a b && echo yes
yes
DOCTEST
assert.var.not_empty(){
    for i in "$@"; do
        [ -n "${!i}" ] || return 1
    done
}

# assert.strlen(){
#     local varname=${1:?Please provide variable name}
#     local val=${!$varname}
#     local len=${#val}
#     local expected_len=${2:?Expected length}
#     if [ "$len" -eq "$expected_len" ]; then
#         return 0
#     else
#         return 1
#     fi
# }

# The following code is ridiculously wrong ...
# assert.str_eq(){
#     local val=${!1:?Please provide variable name}
#     shift
#     for i in "$@"; do
#         if [ "$val" = "$i" ]; then
#             return 0
#         else
#             return 1
#         fi
#     done
# }

# assert.str_match_regex(){
#     local val=${!1:?Please provide variable name}
#     shift
#     for i in "$@"; do
#         if [[ "$val" =~ ^$i$ ]]; then
#             return 0
#         else
#             return 1
#         fi
#     done
# }
