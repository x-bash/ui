# shellcheck shell=bash

str.md5(){
    local cmd
    if command -v md5 >/dev/null 2>&1; then
        cmd=md5
    else
        cmd=md5sum
    fi
    if [ -z "$1" ]; then
        $cmd | cut -d ' ' -f 1
    else
        echo -n "$1" | $cmd | cut -d ' ' -f 1
    fi
}

# TODO: check this function
path.rmrf.safe(){
    local i sw=0 filepath pattern pattern_list=() path_list=() hyphen2=0

    for i in "$@"; do
        if [ "$i" == -- ]; then
            hyphen2=1
        fi
        if [ $hyphen2 -eq 0 ]; then
            pattern_list+=("$i")
        else
            path_list+=("$i")
        fi
    done

    if [ $hyphen2 -eq 0 ]; then
        path_list=("${pattern_list[@]}")
        pattern_list=()
    fi

    for filepath in "${path_list[@]}"; do
        case "$filepath" in
            /)      sw=1; printf "Detect rm -rf /" >&2      ;;
            /bin*)  sw=1; printf "Detect rm -rf /bin" >&2   ;;
            /home)  sw=1; printf "Detect rm -rf /home" >&2  ;;
            *)      for pattern in "${pattern_list[@]}"; do
                        sw=1
                        [[ "$filepath" =~ $pattern ]]
                        printf "Detect violation of RULES: %s" "$pattern" >&2
                    done;;
        esac
    done

    if [ "$sw" -eq 1 ]; then
        printf "file.rm.safe cannot remove the critical files. If you insists, please directly using rm command." >&2
        return 1
    fi

    rm -rf "$@"
}

cache.debug(){
    local IFS=
    [[ "$X_BASH_DEUBG" =~ (^|,)(std/)*cache($|,) ]] && printf "DBG: %s\n" "$@" >&2
}

cache.cmd.help(){
    local IFS=
    printf "%s\n" "$@"

    printf '
------------------
NAME
    cache.cmd -- cache the command result. 
    From std/cache: https://github.com/x-bash/std/blob/master/cache Or https://gitee.com/x-bash/std/blob/master/cache

SYNOPSIS
    cache.cmd [expiration, n[smhdw] ] [cache-filepath] -- <command> [...arguments]

DESCRIPTION
    About expiration, pattern like "n[smhdw]"
        n is number, "smhdw" is unit.
        s       second
        m       minute (60 seconds)
        h       hour (60 minutes)
        d       day (24 hours)
        w       week (7 days)

    If no unit provided, the default unit is "d"

    Example:
        Cache the command result in future 60 minutes (default)
            > cache.cmd -- curl https://x-bash.gitee.io/boot       
        Cache the command result in future 3 days
            > cache.cmd 3 -- curl https://x-bash.gitee.io/boot     
        Cache the command result in future 3 minutess
            > cache.cmd 3m -- curl https://x-bash.gitee.io/boot
        Cache the command result in the file "~/cache" in future 3 hours
            > cache.cmd 3h ~/cache -- curl https://x-bash.gitee.io/boot
'
}

cache.cmd(){
    local IFS=  ARGS=()
    while [ ! "$1" == "--" ]; do
        if [ "$#" -eq 0 ]; then
            cache.cmd.help "PANIC: Expect -- and its following command\n" >&2
            return 1
        fi
        ARGS+=("$1"); shift
    done

    local expiration=60m filepath
    case "${#ARGS[@]}" in
        0) ;;
        1) expiration=${ARGS[0]};;
        *) expiration=${ARGS[0]}; filepath=${ARGS[1]};;
    esac

    if [[ ! "$expiration" =~ ^[0-9]+[dmwsh]?$ ]]; then
        cache.cmd.help "PANIC: Expiration should match pattern n[dmwsh]." >&2
        return 1
    fi

    if [ -z "$filepath" ]; then
        filepath="${X_CMD_X_BASH_CACHE_CMD_FOLDER:-${TMPDIR}x-cmd-path}"
        mkdir -p "$filepath"
        filepath="$filepath/$(str.md5 "$*")"
    fi
    
    if find "$filepath" -mtime "-${expiration}" 2>/dev/null | grep -q ^; then
        [[ "$STD_DEBUG" == *cache* ]] && echo "Using cache in Cache Path: $filepath" >&2
        cat "$filepath"
    else
        [[ "$STD_DEBUG" == *cache* ]] && echo "FILEPATH does't exists or older than ${expiration} second. Update" >&2

        local BACKUP_PATH="$filepath.x-bash.origin.ed15841d4fba5c1dba9045bcbfa0819a"
        if mv "$filepath" "$BACKUP_PATH"; then
            eval "$@" | tee "$filepath"
            rm -rf "$BACKUP_PATH"
        fi
    fi
}

cache.cmd.clear(){
    local FILEPATH="${X_CMD_X_BASH_CACHE_CMD_FOLDER:-${TMPDIR}x-cmd-path}"
    rm -f "$FILEPATH/*"
}

# If you want a new environment for script
cache.cmd.setup(){
    X_CMD_X_BASH_CACHE_CMD_FOLDER="${1:-"$(mktemp)"}"
    export X_CMD_X_BASH_CACHE_CMD_FOLDER
    mkdir -p "$X_CMD_X_BASH_CACHE_CMD_FOLDER"
}

# Remember teardown if you have setup
cache.cmd.teardown(){
    path.rmrf.safe "$X_CMD_X_BASH_CACHE_CMD_FOLDER"
    unset X_CMD_X_BASH_CACHE_CMD_FOLDER
}
