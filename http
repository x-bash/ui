# shellcheck shell=bash

# Using object to make it right

# Using curl
# Using Object
# Provide Github Object, to help automate the github

@src std/dict
@src std/oo

. dict
. oo

http.new(){
    oo.create_new_function http "$@"
}

http.make(){
    dict.make "${1:?Provide name}"
    O="$1" dict.put "url" "${2:?Provide url}"
    # O="$1" dict.put "header" "${3:?Provide default header}"
    # eval "export ${1:?Provide name}_header=()"
}

http.header.add(){
    [ -z "$O" ] && return 1
    dict.put "header.${1:?header key}" "${2:?value}"
}

http.header.content-type.is(){
    :
}

http.header.content-type.is.json(){
    http.header.content-type.is "application/json"
}

http.header.content-type.is.yml(){
    http.header.content-type.is "application/yml"
}

http.header.content-type.is.text(){
    http.header.content-type.is "application/text"
}

http.header.agent.is(){
    :
}

http.header.agent.is.chrome(){
    :
}

http.header.agent.is.ie(){
    :
}

http.header.agent.is.firefox(){
    :
}

http.header.remove(){
    [ -z "$O" ] && return 1
    dict.remove "header.${1:?header key}"
}

http.header.dump(){
    [ -z "$O" ] && return 1
    DICT_PRINT_SEP=': ' dict.print | while read -r l; do
        [[ "$l" =~ ^header\.* ]] && echo "${l:7}"
    done
}

http._dict_get(){
    [ -z "$O" ] && return 1
    dict.get "${1:?Provide key}"
}


http.request(){
    [ -z "$O" ] && return 1
    local URL=${URL:-$(http._dict_get "url")}
    local X=${X:-$(http._dict_get "method")}
    local HEADERS=${X:-$(http._dict_get "header")}
    local D=${D:-$(http._dict_get "data")}
    local QS=${QS:-""}

    if [ -z "$QS" ]; then
        curl -H "${HEADERS[*]}" -x "$X" "$URL/$1"
    else
        curl -H "${HEADERS[*]}" -x "$X" "$URL/$1?$QS"
    fi
}

http.cd(){
    [ -z "$O" ] && return 1
    local URL=${URL:-$(http._dict_get "url")}
    dict.put "url" "$URL/${1:?Provide url}"
}

# TODO: how to cd back

http.path(){
    local URL=${URL:-$(http._dict_get "url")}
    echo "$URL"
}

# X=put D='{} http.request
# http.request(){
#     local method=${X:-GET}
#     local url=${URL:?Provide url environment}

#     curl -H "$(http.header)" -x "$method" "$url"
# }

# put header
# remove header
# list header
http.header(){
    echo "$(http.header.dump)
$HEADER
"
}

http.qs.add(){
    [ -z "$O" ] && return 1
    dict.put "qs.${1:?header key}" "${2:?value}"
}

http.qs.remove(){
    [ -z "$O" ] && return 1
    dict.remove "qs.${1:?header key}"
}

http.qs.dump(){
    [ -z "$O" ] && return 1
    DICT_PRINT_SEP=': ' dict.print | while read -r l; do
        [[ "$l" =~ ^qs\.* ]] && echo "${l:3}"
    done
}

http.eq_str_by_name(){
    for i in "$@"; do
        echo "$i=${!i}"
    done
}

http.body.add(){
    [ -z "$O" ] && return 1
    dict.put "body.${1:?header key}" "${2:?value}"
}

http.body.add_by_name(){
    for i in "$@"; do
        http.body.add "$i" "${!i}"
    done
}

http.body.remove(){
    [ -z "$O" ] && return 1
    dict.remove "body.${1:?header key}"
}

http.body.dump(){
    [ -z "$O" ] && return 1
    DICT_PRINT_SEP=': ' dict.print
    # DICT_PRINT_SEP=': ' dict.print | while read -r l; do
    #     # [[ "$l" =~ ^body\.* ]] && echo "${l:5}"
    #     echo "1: $l"
    # done
}


http.get(){
    X="get" http.request "$@"
}

http.post(){
    X="post" http.request "$@"
}

http.put(){
    X="put" http.request "$@"
}

http.delete(){
    X="delete" http.request "$@"
}


